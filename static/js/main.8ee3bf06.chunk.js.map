{"version":3,"sources":["Page.jsx","App.js","reportWebVitals.js","index.js"],"names":["plane","camera","graphOffset","frontFaces","rightFaces","leftFaces","backFaces","noCull","minimumPoint","maximumPoint","remap","value","low1","high1","low2","high2","minMax","createFakeData","resolution","x0","y0","x1","y1","FAKE_DATA","i","j","Math","sin","pointsX","sqrt","pow","PI","data","addText","text","size","position","MeshBuilder","CreatePlane","width","height","billboardMode","textureGround","DynamicTexture","materialGround","StandardMaterial","diffuseTexture","hasAlpha","backFaceCulling","specularColor","Color3","Black","material","drawText","concat","round","getContext","textAlign","color","White","addLine","start","direction","myPoints","Vector3","x","y","z","CreateLines","points","updateGraph","graphMesh","arguments","length","undefined","positions","getVerticesData","VertexBuffer","PositionKind","localMinimum","localMaximum","thisPoint","X_ID","Y_ID","ELEVATION","updateVerticesData","min","max","val","drawGrid","centerPos","resX","resY","lines","increment","startPos","push","line","rotateAround","Axis","X","Y","Z","alpha","drawLegend","minimum","maximum","margin","textSize","textIncrement","rotation","Zero","onSceneReady","scene","CreateTiledGround","xmin","xmax","subdivisions","w","h","updatable","ArcRotateCamera","wheelPrecision","lowerRadiusLimit","upperRadiusLimit","fov","lockedTarget","canvas","getEngine","getRenderingCanvas","attachControl","HemisphericLight","useVertexColors","stdMaterial","applyMaterials","colors","Array","fill","HEIGHT","colorR","abs","colorG","colorB","setVerticesData","ColorKind","updateColor","forEach","elem","dispose","scale","updateLegend","onRender","isFacingForward","Dot","getForwardRay","Forward","isFacingRight","Left","isFacingLeft","Right","isFacingBack","Backward","isVisible","Page","React","createElement","SceneComponent","antialias","id","App","className","reportWebVitals","onPerfEntry","Function","__webpack_require__","e","then","bind","_ref","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","document","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.8ee3bf06.chunk.js","sourcesContent":["import React from \"react\";\nimport { Vector3, HemisphericLight, MeshBuilder, StandardMaterial, ArcRotateCamera, VertexBuffer, AxesViewer, Color3, DynamicTexture, Color4, Vector2, Axis } from \"@babylonjs/core\";\nimport SceneComponent from 'babylonjs-hook';\nimport \"./App.css\";\n\nlet graphOffset = 0;\nlet plane;\nlet frontFaces = [];\nlet rightFaces = [];\nlet leftFaces = [];\nlet backFaces = [];\nlet noCull = [];\n\nlet minimumPoint = 999999;\nlet maximumPoint = -999999;\nlet camera;\nlet pointsX = 128;\nlet scale = 0.5;\n\nconst distance2D = (x0,y0,x1,y1) => {\n  return Math.sqrt(Math.pow(x1-x0,2)+Math.pow(y1-y0,2))\n}\n\nconst remap = (value,low1,high1,low2,high2) => {\n  return(minMax(low2,high2,low2 + (value - low1) * (high2 - low2) / (high1 - low1),))\n}\n\nconst createFakeData = (resolution) => {\n\n  const FAKE_DATA = []\n\n  for(let i = 0 ; i < resolution; i++){\n    FAKE_DATA[i] = [];\n    for(let j = 0 ; j < resolution; j++){\n      FAKE_DATA[i][j] = Math.sin(distance2D(i,j,pointsX/2,pointsX/2)/pointsX*6 + (Math.PI * 0.5) + graphOffset ) * 20\n    }\n  }\n  return FAKE_DATA;\n}\n\nlet data = createFakeData(pointsX)\n\nconst addText = (text,size,resolution,position) => {\n\n  //Setup and Position\n  let plane = MeshBuilder.CreatePlane(\"text\", {width: size*50, height : size});\n  plane.position = position\n  plane.billboardMode = 2;\n\n  //Create dynamic texture\n\tvar textureGround = new DynamicTexture(\"dynamic texture\", {width:resolution*50, height:resolution});   \n\t\n  //Create a flat material\n\tvar materialGround = new StandardMaterial(\"Mat\");    \t\t\t\t\n\tmaterialGround.diffuseTexture = textureGround;\n  materialGround.diffuseTexture.hasAlpha = true;\n  materialGround.backFaceCulling = false;\n  materialGround.specularColor = Color3.Black()\n\tplane.material = materialGround;\n\n\n  //Add text to dynamic texture\n  textureGround.drawText(text, null, null, `${Math.round(resolution)}px regular`, \"white\",\"\", true, true);\n  textureGround.getContext().textAlign = \"center\"\n  plane.color = Color3.White()\n\n  return plane\n}\n\nconst addLine = (start,direction) => {\n  const myPoints = [\n    start,\n    new Vector3(start.x+direction.x,start.y+direction.y,start.z+direction.z)\n  ]\n\n  return MeshBuilder.CreateLines(\"lines\", {points: myPoints});\n}\n\nconst updateGraph = (graphMesh,data = false) => {\n  let positions = graphMesh.getVerticesData(VertexBuffer.PositionKind);\n  let localMinimum = 999999, localMaximum = -999999;\n  // Get the local Minimum and Maximum\n  for(let i = 0 ; i < data.length; i++){\n    for(let j = 0 ; j < data.length; j++){\n      let thisPoint = data[i][j];\n\n      if(thisPoint < localMinimum){\n        localMinimum = thisPoint;\n      }\n\n      else if (thisPoint > localMaximum){\n        localMaximum = thisPoint;\n      }\n\n    }\n  }\n\n  minimumPoint = localMinimum;\n  maximumPoint = localMaximum;\n\n  //move the graph points and scale it\n  for(let i = 0 ; i < positions.length; i+=3){\n    let x = positions[i];\n    let y = positions[i+1];\n    let z = positions[i+2];\n\n    const X_ID = Math.round(remap(x,-1,1,0,pointsX-1))\n    const Y_ID = Math.round(remap(z,-1,1,0,pointsX-1))\n\n    const ELEVATION = data ? data[X_ID][Y_ID] : Math.sin((x+y)*10)/10\n    positions[i+1] = remap(ELEVATION,minimumPoint,maximumPoint,-scale,scale)\n    //positions[i+1] = Math.random()\n    //positions[i] = Math.random()\n  }\n\n\n  graphMesh.updateVerticesData(VertexBuffer.PositionKind, positions);\n}\n\nconst minMax = (min,max,val) => {\n  return (Math.min(max,Math.max(min,val)))\n}\n\nconst updateColor = (graphMesh) => {\n  let colors  = new Array( pointsX * pointsX *pointsX ).fill(1) //= graphMesh.getVerticesData(VertexBuffer.ColorKind);\n  let positions = graphMesh.getVerticesData(VertexBuffer.PositionKind);\n\n  for(let i = 0 ; i < colors.length; i+=4){\n\n    const HEIGHT = positions[(i*3/4)+1]\n\n\n    let colorR = HEIGHT < 0 ? Math.abs(HEIGHT/scale) : 0\n\n    let colorG = HEIGHT > 0 ? Math.abs(HEIGHT/scale) : 0\n\n    let colorB = 1-Math.abs(HEIGHT/scale)\n\n    colors[i] =  colorR\n    colors[i+1] = colorG //colorG\n    colors[i+2] = colorB //colorB\n  }\n  \n\n  graphMesh.setVerticesData(VertexBuffer.ColorKind, colors);\n}\n\nconst applyMaterials = (graphMesh) => {\n  let stdMaterial = new StandardMaterial(\"stdMaterial\");\n  graphMesh.material = stdMaterial\n  stdMaterial.specularColor = Color3.Black()\n  stdMaterial.backFaceCulling = false\n  //stdMaterial.wireframe = true;\n}\n\nconst drawGrid = (centerPos,direction,width,height,resX,resY) => {\n  let lines = []\n\n  for(let i = 0 ; i < resY; i++){\n    let increment = height / (resY-1);\n\n    let startPos = new Vector3(centerPos.x - (width*0.5),centerPos.y-(height*0.5) + (increment * i),centerPos.z);\n\n    lines.push(addLine(startPos,new Vector3(width,0,0)))\n  }\n\n  for(let i = 0 ; i < resX; i++){\n\n    let increment = width / (resX-1);\n\n    const startPos = new Vector3(centerPos.x - (width*0.5) + (increment * i),centerPos.y-(height*0.5),centerPos.z)\n    lines.push(addLine(startPos, new Vector3(0,height,0)))\n  }\n\n  for(let i = 0 ; i < lines.length; i++){\n    let line = lines[i];\n    line.rotateAround(centerPos,Axis.X,direction.x/180*Math.PI);\n    line.rotateAround(centerPos,Axis.Y,direction.y/180*Math.PI);\n    line.rotateAround(centerPos,Axis.Z,direction.z/180*Math.PI);\n    line.color = Color3.Black();\n    line.alpha = 0.5\n  }\n\n  return lines;\n}\n\nconst drawLegend = (centerPos,direction,width,minimum,maximum,resX,margin,textSize) => {\n  let lines = []\n\n  for(let i = 0 ; i < resX; i++){\n\n    let increment = width / (resX-1);\n    let textIncrement = Math.round(remap(i,0,resX-1,minimum,maximum)*10)/10;\n\n    const startPos = new Vector3(centerPos.x - (width*0.5) + (increment * i),centerPos.y,centerPos.z)\n\n    if(i === 0){\n      lines.push(addText(textIncrement,textSize,128, new Vector3(startPos.x+(margin),startPos.y,startPos.z))) // BOTTOM TEXT\n    }\n    else if(i < resX-1){\n      lines.push(addText(textIncrement,textSize,128, startPos)) // BOTTOM TEXT\n    }\n    else if(i === resX-1){\n      lines.push(addText(textIncrement,textSize,128, new Vector3(startPos.x-(margin),startPos.y,startPos.z))) // BOTTOM TEXT\n    }\n\n  }\n\n  for(let i = 0 ; i < lines.length; i++){\n    let line = lines[i];\n    line.rotateAround(centerPos,Axis.X,direction.x/180*Math.PI);\n    line.rotateAround(centerPos,Axis.Y,direction.y/180*Math.PI);\n    line.rotateAround(centerPos,Axis.Z,direction.z/180*Math.PI);\n    line.rotation = Vector3.Zero()\n  }\n\n  return lines;\n}\n\nconst updateLegend = () => {\n\n  frontFaces.forEach((elem) => {elem.dispose()})\n  rightFaces.forEach((elem) => {elem.dispose()})\n  leftFaces.forEach((elem) => {elem.dispose()})\n  backFaces.forEach((elem) => {elem.dispose()})\n  noCull.forEach((elem) => {elem.dispose()})\n\n  frontFaces = [];\n  backFaces = [];\n  rightFaces = [];\n  leftFaces = [];\n  noCull = [];\n  // create the lines\n\n  frontFaces = drawGrid(new Vector3(0,0,-1),new Vector3(0,0,0),2,scale*2,5,5);\n  backFaces = drawGrid(new Vector3(0,0,1),new Vector3(0,0,0),2,scale*2,5,5);\n  leftFaces = drawGrid(new Vector3(-1,0,0),new Vector3(0,90,0),2,scale*2,5,5);\n  rightFaces = drawGrid(new Vector3(1,0,0),new Vector3(0,90,0),2,scale*2,5,5)\n  drawGrid(new Vector3(0,-scale,0),new Vector3(90,0,0),2,2,5,5) // floor grid\n\n  let textSize = 0.03\n\n  //add the horizontal text\n\n  frontFaces = frontFaces.concat(drawLegend(new Vector3(0,scale+0.025,-1) , new Vector3(0,0,0) , 2 , 0 , pointsX , 5 , textSize*1.5,textSize))\n  backFaces = backFaces.concat(drawLegend(new Vector3(0,scale+0.025,1) , new Vector3(0,0,0) , 2 , 0 , pointsX , 5 , textSize*1.5,textSize))\n  leftFaces = leftFaces.concat(drawLegend(new Vector3(-1,scale+0.025,0) , new Vector3(0,-90,0) , 2 , 0 , pointsX , 5 , textSize*1.5,textSize))\n  rightFaces = rightFaces.concat(drawLegend(new Vector3(1,scale+0.025,0) , new Vector3(0,-90,0) , 2 , 0 , pointsX , 5 , textSize*1.5,textSize))\n\n  //add the bottom text (doesn't cull)\n\n  noCull = noCull.concat(drawLegend(new Vector3(0,-scale-0.025,-1),new Vector3(0,0,0),2 , 0 , pointsX , 5,textSize*1.5,textSize));\n  noCull = noCull.concat(drawLegend(new Vector3(0,-scale-0.025,1),new Vector3(0,0,0),2 , 0 , pointsX , 5,textSize*1.5,textSize));\n  noCull = noCull.concat(drawLegend(new Vector3(-1,-scale-0.025,0),new Vector3(0,-90,0),2 , 0 , pointsX , 5,textSize*1.5,textSize));\n  noCull = noCull.concat(drawLegend(new Vector3(1,-scale-0.025,0),new Vector3(0,-90,0),2 , 0 , pointsX , 5,textSize*1.5,textSize));\n  \n  // add the vertical text (duplicates for propper culling)\n  frontFaces = frontFaces.concat(drawLegend(new Vector3(-1,0,-1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n  leftFaces = leftFaces.concat(drawLegend(new Vector3(-1,0,-1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n\n  frontFaces = frontFaces.concat(drawLegend(new Vector3(1,0,-1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n  rightFaces = rightFaces.concat(drawLegend(new Vector3(1,0,-1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n\n  leftFaces = leftFaces.concat(drawLegend(new Vector3(-1,0,1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n  backFaces = backFaces.concat(drawLegend(new Vector3(-1,0,1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n\n  rightFaces = rightFaces.concat(drawLegend(new Vector3(1,0,1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n  backFaces = backFaces.concat(drawLegend(new Vector3(1,0,1),new Vector3(0,0,90),scale*2 , minimumPoint, maximumPoint , 5,textSize*0.5,textSize))\n}\n\nconst onSceneReady = (scene) => {\n  // This creates and positions a free camera (non-mesh)\n  plane = MeshBuilder.CreateTiledGround(\"tiled ground\",{xmin : -1 , xmax : 1 ,subdivisions : {w: pointsX-1, h: pointsX-1},updatable:true},scene)\n\n  camera = new ArcRotateCamera(\"camera\", -Math.PI / 2, Math.PI / 2.5, 3, new Vector3(0, 0, 0), scene);\n  camera.wheelPrecision = 30\n  camera.lowerRadiusLimit = 15\n  camera.upperRadiusLimit = 1000\n  camera.fov = 0.1\n\n\n  // This targets the camera to scene origin\n  camera.lockedTarget = plane;\n\n  const canvas = scene.getEngine().getRenderingCanvas();\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  const light = new HemisphericLight(\"light\", new Vector3(0, 1, 0), scene);\n\n  plane.useVertexColors = true;\n  \n  applyMaterials(plane)\n\n  updateGraph(plane,data)\n  \n  updateColor(plane)\n\n  updateLegend()\n\n};\n\n\nconst onRender = (scene) => {\n\n  let frontDot = Vector3.Dot(camera.getForwardRay().direction, Vector3.Forward())\n  let rightDot = Vector3.Dot(camera.getForwardRay().direction, Vector3.Left())\n  let leftDot = Vector3.Dot(camera.getForwardRay().direction, Vector3.Right())\n  let backDot = Vector3.Dot(camera.getForwardRay().direction, Vector3.Backward())\n  let limit = 0.1 ;\n\n  let isFacingForward = (frontDot >= limit);\n  let isFacingRight = (rightDot >= limit);\n  let isFacingLeft = (leftDot >= limit);\n  let isFacingBack = (backDot >= limit);\n\n  frontFaces.forEach((elem) => {elem.isVisible = true})\n  rightFaces.forEach((elem) => {elem.isVisible = true})\n  leftFaces.forEach((elem) => {elem.isVisible = true})\n  backFaces.forEach((elem) => {elem.isVisible = true})\n\n  if(isFacingForward){\n    frontFaces.forEach(elem => {(elem.isVisible = false)})\n  }\n  if(isFacingRight){\n    rightFaces.forEach(elem => {(elem.isVisible = false)})\n  }\n  if(isFacingLeft){\n    leftFaces.forEach(elem => {(elem.isVisible = false)})\n  }\n  if(isFacingBack){\n    backFaces.forEach(elem => {(elem.isVisible = false)})\n  }\n\n  graphOffset += 0.005;\n  \n  updateGraph(plane,createFakeData(pointsX))\n};\n\n\nexport default () => (\n  <div>\n    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} id=\"my-canvas\" />\n  </div>\n);","import React from 'react'\nimport Page from './Page';\n\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Page/>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}